# 可靠性

每个人都有一个直观的感觉来评判一样事物到底是可靠还是不可靠。对于软件产品而言，人们对可靠性的期待通常有：
- 应用能够提供用户期望的功能；
- 软件能够容忍用户犯错，在用户以期望之外的操作来使用软件时也不会崩溃；
- 在可预期的负载和数据量下，软件的性能可以支撑用户的使用场景；
- 软件系统能够防止滥用授权或者未授权的访问；

如果上述的行为意味着"正确地工作"，那么我们对*可靠性*的描述可以粗略地概括为"哪怕有一些错误（组件宕机，用户调皮，……），软件也能继续正确地工
作（避免错误，或者自动从错误中恢复）"。

那些有可能出现的问题被称为*错误*，而能感知并处理错误的系统则被称为*容错的*或*弹性的*（译者还推荐*鲁棒的*，*健壮的*这些有画面感的词）。前
者，容错的，容易产生一些误解：似乎是说我们能够实现一套容忍任何可能错误的系统，而这在现实中是不可能的。如果整个地球连同地球上所有的服务器都
被一个黑洞吞噬了，那么就需要在太空中部署网络来实现这个所谓的容错性了，嗯你最好能拿到预算。所以我们其实只在讨论容忍*特定类型*的错误。

请注意错误并非失效[[2]](../../README.md#b1_c1_2)。错误被定义为一个系统组件偏离了定义的行为，而*失效*是系统整体无法再给用户提供服务。
由于我们几乎不可能把错误率减到0，因此往往是设计一套容错机制来防止错误导致失效。这本书将会讨论多种技术来将可靠性低的部件搭建成高可靠的系统。

有悖常理地，在这样一种容错系统中故意触发错误，比如在预警之外随机杀死一个进程，是有意义的。很多严重的事故的诞生就是由于错误处理机制实在太烂
了[[3]](../../README.md#b1_c1_3)，而故意引发错误可以使得你的容错机制持续得到检验，你会确信当错误自然发生的时候他们能够被正确地处理。
Netflix的Chaos Monkey[[4]](../../README.md#b1_c1_4)（译者注：一个捣乱的猴子，随机挑选若干服务节点和进程，干掉）就是这样一个例子。

尽管总体上来说，相比于错误的预防，我们对错误的恢复能力会有更多的探讨，但是仍然有很多场景下预防错误比恢复错误更加重要，因为事实上根本没有任
何方式可以恢复错误，比如安全问题。设想一个攻击者已经攻破了一套系统，并且获得了读写敏感数据的权限，任何的恢复措施都于事无补。不管怎样，这本
书大部分都是针对可以恢复的错误进行探讨。在此之前，我们会用接下来几节来概述这些错误。
